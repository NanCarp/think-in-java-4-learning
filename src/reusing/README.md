p143  
final 和 private 关键字  
类中所有的 private 方法都是隐式地指定为是 final 的。由于无法取用 private 方法，所以也就无法覆盖它。  
FinalOverridingIllusion.java  
“覆盖”只有在某方法是基类的接口的一部分时才会出现。即，必须能将一个对象向上转型为它的基本类型并调用相同的方法。
如果某方法为 private，它就不是基类的接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同的名称而已。但
如果在导出类中以相同的名称生成一个 public、protected 或包访问权限方法的话，该方法就不会产生在基类中出现的“仅具有
相同名称”的情况。此时并没有覆盖该方法，仅是生成了一个新的方法。
p156
缺陷：“覆盖”私有方法  
PrivateOverride.java  
期望输出 public f()，但是由于 private 方法被自动认为是 final 方法，而且对于导出类是屏蔽的。因此，在这种情况下，
Derived 类中的 f() 方法就是一个全新的方法；既然基类中的 f() 方法在子类中不可见，因此甚至也不能被重载。  
结论：只有非 private 方法才可以被覆盖；在导出类中，对于基类的 private 方法，最好采用不同的名字。  
缺陷：域与静态方法  
如果某个方法是静态的，它的行为就不具有多态性：  
StaticPolymorphysim.java  
静态方法是与类，而并非是与单个的对象相关联的。   
p162  
构造器内部的多态方法的行为   
P165  