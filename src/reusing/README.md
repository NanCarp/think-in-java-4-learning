p143  
final 和 private 关键字  
类中所有的 private 方法都是隐式地指定为是 final 的。由于无法取用 private 方法，所以也就无法覆盖它。  
FinalOverridingIllusion.java  
“覆盖”只有在某方法是基类的接口的一部分时才会出现。即，必须能将一个对象向上转型为它的基本类型并调用相同的方法。
如果某方法为 private，它就不是基类的接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同的名称而已。但
如果在导出类中以相同的名称生成一个 public、protected 或包访问权限方法的话，该方法就不会产生在基类中出现的“仅具有
相同名称”的情况。此时并没有覆盖该方法，仅是生成了一个新的方法。
p156
缺陷：“覆盖”私有方法  
PrivateOverride.java  
期望输出 public f()，但是由于 private 方法被自动认为是 final 方法，而且对于导出类是屏蔽的。因此，在这种情况下，
Derived 类中的 f() 方法就是一个全新的方法；既然基类中的 f() 方法在子类中不可见，因此甚至也不能被重载。  
结论：只有非 private 方法才可以被覆盖；在导出类中，对于基类的 private 方法，最好采用不同的名字。  
缺陷：域与静态方法  
如果某个方法是静态的，它的行为就不具有多态性：  
StaticPolymorphysim.java  
静态方法是与类，而并非是与单个的对象相关联的。  